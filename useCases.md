# USE CASES

> Далее предполагаем, что используется [git-flow](https://www.atlassian.com/ru/git/tutorials/comparing-workflows/gitflow-workflow) либо [Trunk-based development](https://www.atlassian.com/ru/continuous-delivery/continuous-integration/trunk-based-development), а миграции лежат в отдельном репозитории вида _<project_name>.liquibase_. Для всех других случаев все будет в целом аналогично

## Создание новой миграции БД
*Разработчик хочет сделать некоторое изменение схемы одной из БД и добавить это изменение в следующий релиз*

#### Как будет выглядеть для него процесс?

**Answer:**

  1. получаем все обновления проекта миграций
    ```bash
    cd <serviceName>.liquibase
    git checkout -b "master"
    git fetch --all
    git pull
    git checkout -B "feature/<issue_id>"
    ```
  2. в каталоге `migrations` [создаем файл миграции](./demo/README.md#создание-миграций)
  3. коммитим изменения
    ```bash
    git add --all
    git commit -m "<issue_id>"
    git push
    ```
  4. создаем pull-request в `master` 

#### Как он будет убеждаться, что созданная им миграция вообще работает?

**Answer:**

Например, можно достаточно просто [проверить локально](./demo/README.md#подготовка-пустой-бд-в-контейнере)

#### Как он будет убеждаться, что созданная им миграция делает то, что он ожидает?

**Answer:**

Аналогично предыдущему пункту

#### Как он сможет продолжить работать, например писать и тестировать сервис, который завязан на эту миграцию?

**Answer:**

Если БД развернута локально, то [разворачиваем локально контейнер БД и накатываем на него все миграции](./demo/README.md). В случае тестового стенда - аналогично вышеописанному пукту [процесса](#как-будет-выглядеть-для-него-процесс), но pull-request будет не в `master`, а в `dev`

#### Как будут работать другие разработчики?
*в том числе которым нужна или наоборот НЕ нужна эта миграция*

**Answer:**

Те, кому необходима миграция, получают ее, закачав соответвующую ветку репозитория миграций. Если же большинству разработчиков нужна эта миграция, то она закачивается на `dev` и деплоится на стенд разработки.

## Обеспечение защиты от падения прода при накате миграций
*Разработчики добавили в систему новую миграцию. Возможно эта миграция задействует основные таблицы БД. Мы хотим быть уверены, что ее применение на проде не приведет к деградации сервиса в процессе развертывания миграции*

**Answer:**

`Liquibase` нельзя назвать "серебряной пулей" или "волшебной палочкой", это лишь инструмент управления миграциями. Без построения полноценного процесса CI/CD, обязательно включающего тестирование, таких гарантий получить невозможно - `liquibase` не может отвечать за работоспособность сторонних утилит.

## Связанные миграции схемы БД и обновления сервисов
*Разработчик хочет внести новый функционал. Для этого необходимо добавить в таблицу `Т` `non-nullable` поле `F`. Эта таблица используется сервисом `S` на запись. Сервис `S` важный и его нельзя просто обновить. Ожидаемая последовательность действий:*
1. *В таблицу `T` добавляется поле `F`, но `nullable`*
2. *Текущая версия сервиса `S` заменяется (gracefully) новой, которая умеет писать значения в поле `F` (это занимает время)*
3. *После обновления сервиса запускается процедура ретрофита данных, которая заполняет значения в поле `F` для старых записей (это занимает время)*
4. *После того, как все строки таблицы `T` получают значения в поле `F` меняется constraint на `non-nullable`*

- *как это обеспечить? Понятно, что пример упрощенный, так как на самом деле есть еще сервисы, которые читают данные из таблицы `T` и их можно обновить только после этапа 3, а еще индексы и пр.*
- *Как убедиться, что пп3 и 4 не положат прод под нагрузкой на БД?*

**Answer:**

Краткий ответ - **не делайте так!**
1. Так как поля еще не существует, значит никакие сервисы его не используют
2. Необходимо убедиться, что в сервисах нет конструкций вида `SELECT * ...` etc.
3. Если сервисы накатываются автоматически, в билде должна быть проверка метки (label) актуальной БД
4. Накатываем миграцию, которая добавит `non-nullable` поле `F` со значением по умолчанию, используя функционал [labels](https://docs.liquibase.com/concepts/changelogs/attributes/labels.html)
5. Затем уже обновляем все сервисы, использующие новое поле, если они не обновились автоматически

## Изменения на проде
*Внезапно понадобилось СРОЧНО внести изменения на один из продакшен-стендов, например, на проде все тормозит и нужно срочно добавить индекс, иначе все встанет прямо сейчас.*
*Как это делать? Разрешаем ли мы менять что-то напрямую на проде?*
- *Если да, то как потом жить с "разъехавшимися" стендами?*
- *Если нет, то как делать срочные фиксы?*

**Answer:**

Согласно современным методам разработки ([git-flow](https://www.atlassian.com/ru/git/tutorials/comparing-workflows/gitflow-workflow) либо [Trunk-based development](https://www.atlassian.com/ru/continuous-delivery/continuous-integration/trunk-based-development)) в репозитории миграций создаются ветки `hotfix/<bug_id>`, которые далее отправляются на релиз и в `dev`

## Изменения, специфичные для единичного стенда
*Нужно внести изменения, которые должны появиться только на одном стенде. Например, в `банке А` нужно добавить новую таблицу и сервис, которых нет на других стендах*
- *Как это делать?*
- *Как обеспечить "непротекание" изменений на другие стенды?*
- *Как обеспечить совместимость последующих изменений от других стендов с этим специфичным изменением?*

**Answer:**

В зависимости от особенностей ситуации можно использовать [labels](https://docs.liquibase.com/concepts/changelogs/attributes/labels.html) или [contexts](https://docs.liquibase.com/concepts/changelogs/attributes/contexts.html), подробный разбор что лучше подходит для конкретной ситуации есть в [официальной документации](https://www.liquibase.com/blog/contexts-vs-labels)

## Репликация прод БД в тест

**Answer:**

С помощью [contexts](https://docs.liquibase.com/concepts/changelogs/attributes/contexts.html) миграции, которые предназначены только для теста или только для прода помечаются соответственно.

## Релизы в гитлабе, план релизов
*Как поступать, если требуется сложный план выкладки, например сначала выложить первую часть миграций с определенной меткой, затем обновить часть сервисов, затем следующую часть миграций и т.д.*

**Answer:**

Для сложных алгоритмов разумно использовать предназначенные для этого инструменты - [jenkins](https://www.jenkins.io) и [ansible](https://www.ansible.com)

## Релизы в коробку на чужой изолированный контур

**Answer:**

Аналогично предыдущему пункту, для подготовки и выполнения развертывания используются [jenkins](https://www.jenkins.io) и [ansible](https://www.ansible.com)

