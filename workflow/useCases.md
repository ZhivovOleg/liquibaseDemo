# USE CASES

## Создание новой миграции БД
*Разработчик хочет сделать некоторое изменение схемы одной из БД и добавить это изменение в следующий релиз*

#### Как будет выглядеть для него процесс?
> Далее предполагаем, что используется классический git-flow, а миграции лежат в отдельном репозитории. Для всех других случаев все будет в целом аналогично

  1. получаем все обновления проекта миграций
    ```bash
    cd <serviceName>.liquibase
    git checkout -b "master"
    git fetch --all
    git pull
    git checkout -B "feature/<issue_id>"
    ```
  2. в каталоге `migrations` [создаем файл миграции](./../demo/README.md#создание-миграций)
  3. коммитим изменения
    ```bash
    git add --all
    git commit -m "<issue_id>"
    git push
    ```
  4. создаем pull-request в `master` 

#### Как он будет убеждаться, что созданная им миграция вообще работает?
Например, можно достаточно просто [проверить локально](./../demo/README.md#подготовка-пустой-бд-в-контейнере)

#### Как он будет убеждаться, что созданная им миграция делает то, что он ожидает?
Аналогично предыдущему пункту

#### Как он сможет продолжить работать, например писать и тестировать сервис, который завязан на эту миграцию?
Если БД развернута локально, то [разворачиваем локально контейнер БД и накатываем на него все миграции](./../demo/README.md). В случае тестового стенда - аналогично вышеописанному пукту [процесса](#как-будет-выглядеть-для-него-процесс), но pull-request будет не в `master`, а в `dev`

#### Как будут работать другие разработчики?
*в том числе которым нужна или наоборот НЕ нужна эта миграция*

Те, кому необходима миграция, получают ее, закачав соответвующую ветку репозитория миграций. Если же большинству разработчиков нужна эта миграция, то она закачивается на `dev` и деплоится на стенд разработки.

## Обеспечение защиты от падения прода при накате миграций
*Разработчики добавили в систему новую миграцию. Возможно эта миграция задействует основные таблицы БД. Мы хотим быть уверены, что ее применение на проде не приведет к деградации сервиса в процессе развертывания миграции*


## Связанные миграции схемы БД и обновления сервисов
*Разработчик хочет внести новый функционал. Для этого необходимо добавить в таблицу `Т` `non-nullable` поле `F`. Эта таблица используется сервисом `S` на запись. Сервис `S` важный и его нельзя просто обновить. Ожидаемая последовательность действий:*
1. *В таблицу `T` добавляется поле `F`, но `nullable`*
2. *Текущая версия сервиса `S` заменяется (gracefully) новой, которая умеет писать значения в поле `F` (это занимает время)*
3. *После обновления сервиса запускается процедура ретрофита данных, которая заполняет значения в поле `F` для старых записей (это занимает время)*
4. *После того, как все строки таблицы `T` получают значения в поле `F` меняется constraint на `non-nullable`*

- *как это обеспечить? Понятно, что пример упрощенный, так как на самом деле есть еще сервисы, которые читают данные из таблицы `T` и их можно обновить только после этапа 3, а еще индексы и пр.*
- *Как убедиться, что пп3 и 4 не положат прод под нагрузкой на БД?*

## Изменения на проде
*Внезапно понадобилось СРОЧНО внести изменения на один из продакшен-стендов, например, на проде все тормозит и нужно срочно добавить индекс, иначе все встанет прямо сейчас.*
*Как это делать? Разрешаем ли мы менять что-то напрямую на проде?*
- *Если да, то как потом жить с "разъехавшимися" стендами?*
- *Если нет, то как делать срочные фиксы?*

## Изменения, специфичные для единичного стенда
*Нужно внести изменения, которые должны появиться только на одном стенде. Например, в `банке А` нужно добавить новую таблицу и сервис, которых нет на других стендах*
- *Как это делать?*
- *Как обеспечить "непротекание" изменений на другие стенды?*
- *Как обеспечить совместимость последующих изменений от других стендов с этим специфичным изменением?*




